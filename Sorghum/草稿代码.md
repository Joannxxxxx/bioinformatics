```python
# 计算维管束二级数据
import math
tmp["维管束总数目"] = tmp["大维管束数目"] + tmp["小维管束数目"]
tmp["大维管束面积和"] = tmp["大维管束数目"] * tmp["大维管束平均面积"]
tmp["小维管束面积和"] = tmp["小维管束数目"] * tmp["小维管束平均面积"]
tmp["维管束面积总和"] = tmp["大维管束面积和"] + tmp["小维管束面积和"]
tmp["去腔茎面积"] = tmp["茎面积"] - tmp["空腔面积"]
tmp["皮厚度"] = tmp["茎直径"]/2 - tmp["内环半径"]
tmp["内环面积"] = math.pi * tmp["内环半径"] ** 2
tmp["皮面积"] = tmp["茎面积"] - tmp["内环面积"]

tmp["大维管束数目占比"] = 100 * tmp["大维管束数目"] / tmp["维管束总数目"]
tmp["大维管束面积占比"] = 100 * tmp["大维管束面积和"] / tmp["维管束面积总和"]
tmp["大小维管束平均面积比值"] = tmp["大维管束平均面积"] / tmp["小维管束平均面积"]
tmp["大维管束相对离心距"] = 2 * tmp["大维管束离心距"] / tmp["茎直径"]
tmp["小维管束相对离心距"] = 2 * tmp["小维管束离心距"] / tmp["茎直径"]
tmp["大维管束面积占茎百分比"] = 100 * tmp["大维管束面积和"] / tmp["去腔茎面积"]
tmp["大维管束面积占内环百分比"] = 100 * tmp["大维管束面积和"] / (tmp["内环面积"]-tmp["空腔面积"])
tmp["小维管束面积占茎百分比"] = 100 * tmp["小维管束面积和"] / tmp["去腔茎面积"]
tmp["小维管束面积占皮百分比"] = 100 * tmp["小维管束面积和"] / tmp["皮面积"]
tmp["小维管束“周长密度”"] = tmp["小维管束数目"] / tmp["茎周长"]
tmp["小维管束“面积密度”"] = tmp["小维管束数目"] / tmp["皮面积"]
tmp["大维管束“面积密度”"] = tmp["大维管束数目"] / (tmp["内环面积"]-tmp["空腔面积"])
```


```python
def data_imputed(df,n):
    from sklearn.impute import KNNImputer

    imputer = KNNImputer(n_neighbors=n)
    imputed = imputer.fit_transform(df)
    df_imputed = pd.DataFrame(imputed, columns=df.columns,index=df.index)
    return df_imputed
```

```python
def scale_and_cor_heatmap(data):
    # 标准化
    data_scale = data_standard(data)
    data_scale.head(2)

    #皮尔森相关系数
    pearson = data_scale.corr(method="pearson")

    sns.clustermap(pearson,
                   cmap="vlag",
    #                linewidths=.1,
                   figsize=(20, 20),               
                   annot=True, 
                   fmt="1.1f",                 
                   cbar_kws={"shrink": 0.25,"pad":0.01,}
                  )
```

```python
def dropna_dropout_then_pair_cor(data,filepath,cols):
    """
    画两季性状两两之间的散点图，带相关系数
    :param data: 接收 pandas.DataFrame 数据格式
    :param filepath: 保存路径
    :param cols: 选择的性状
    """  
    tmp = data.copy()
    drop_dict = {}
    for col in cols:
        # 1、把同性状拿出来
        xname = col + "_x"
        yname = col + "_y"
        
        ind = data["品种编号"]
        x = data.loc[:,xname]
        y = data.loc[:,yname]
        xy = pd.concat([ind,x,y],axis=1) # 取出两年同性状的数据
        
        # 2、去掉缺失
        xna_list = data[data[xname].isnull()]["品种编号"].tolist() # xcol 的缺失样本
        yna_list = data[data[yname].isnull()]["品种编号"].tolist() # ycol 的缺失样本
        na_list = list(set(xna_list + yna_list))
        
        xy_dropna = xy[~xy["品种编号"].isin(na_list)] # 删掉缺失样本后
        
        # 3、计算同性状比值
        col_bi = col + "比"
        xy_dropna[col_bi] = xy_dropna[yname] / xy_dropna[xname]
        
        # 4、对比值进行离群点筛查
        minimun,maximun = get_outliers(xy_dropna[col_bi],1.5)
        pzbh_list = xy_dropna[(xy_dropna[col_bi] < minimun) | (xy_dropna[col_bi] > maximun)]["品种编号"].tolist() # 离群点的编号
        
        drop_dict[col] = {"xna_list": xna_list,
                          "xna_number":len(xna_list),
                         "yna_list":yna_list,
                          "yna_number":len(yna_list),
                         "na_list":na_list,
                          "na_number":len(na_list), 
                          "outliners": pzbh_list,
                         "outliners_number":len(pzbh_list),
                         "remain_number":data.shape[0] - len(na_list) - len(pzbh_list)       
                        } # 把缺失情况和离群点情况记录入字典
        
        # 5、在原数据上和同性状 xy 矩阵上删掉离群点
        tmp.loc[tmp["品种编号"].isin(pzbh_list),xname] = np.nan # 在原数据里把异常值删掉
        tmp.loc[tmp["品种编号"].isin(pzbh_list),yname] = np.nan
        xy_dropna_dropout = xy_dropna[~xy_dropna["品种编号"].isin(pzbh_list)] # 在单独拿出的同性状数据里删掉离群点
        xy_dropna_dropout = xy_dropna_dropout.set_index("品种编号")
        
        # 6、计算相关系数并画图
        sns.regplot(xname,yname,data=xy_dropna_dropout,color="b",scatter_kws={'alpha':0.3})
        
        xy_corr = xy_dropna_dropout.corr(method="pearson") # 计算相关系数矩阵
        rvalue = xy_corr.iloc[0,1]
        rvalue = round(rvalue,2) # 提取相关系数
        pval_matrix = xy_dropna_dropout.corr(method=lambda x, y: pearsonr(x, y)[1]) - np.eye(len(xy.columns)) # 计算 p 值矩阵
        pval = pval_matrix.iloc[0,1] # 提取 p 值
        plot_rvalue_and_pvalue(rvalue,pval) # 写上相关系数和显著性水平

        
        col = col.replace('/', 'sub')
        savepath = filepath + col + ".pdf" 
        plt.savefig(savepath, bbox_inches = 'tight') # 保存图片

        plt.show() # 展示图片
    return tmp,drop_dict
``` 
    
    
```python
# 数据版本范 4.1.1 对应的离群点删除标准
# 去掉异常值并且绘制相关系数图
def remove_outliners_then_plot(data,cols_impot,filepath):
    from scipy.stats import pearsonr
    tmp = data.copy()
    
    out_dict = {}
    for col in vb_cols:
        print(col)
        col_bi = col + "比"
        
        if col == "小维管束数目":
            pzbh_list = get_outliner_index_shougong(data,"品种编号",col,0.7,2.2) 
        elif col == "小维管束平均面积":
            pzbh_list = get_outliner_index_shougong(data,"品种编号",col,0.5,2.8)
        elif col == "大维管束平均面积":
            pzbh_list = get_outliner_index_shougong(data,"品种编号",col,0.7,2.8)
        else:
            minimun,maximun = get_outliers(data[col_bi],1.5)
            pzbh_list = data[(data[col_bi] < minimun) | (data[col_bi] > maximun)]["品种编号"].tolist() # 离群点的编号
        print(pzbh_list)  
        out_dict[col] = {"outliners": pzbh_list,
                         "outliners_number":len(pzbh_list),
                         "remain_number":data.shape[0] - len(pzbh_list),
                        } # 把离群点加到字典中

        
        xname =  col + "_x"
        yname =  col + "_y"
        
        tmp.loc[tmp["品种编号"].isin(pzbh_list),xname] = np.nan # 把异常值删掉
        tmp.loc[tmp["品种编号"].isin(pzbh_list),yname] = np.nan
        
        x = tmp.loc[~tmp["品种编号"].isin(pzbh_list),xname] # 去掉离群点后的第一季数据
        y = tmp.loc[~tmp["品种编号"].isin(pzbh_list),yname] # 去掉离群点后的第二季数据
        xy = pd.concat([x,y],axis=1)
        print(xy.shape)
        
        sns.regplot(xname,yname,data=data,color="b",scatter_kws={'alpha':0.3}) # 画散点图
        
        xy_corr = xy.corr(method="pearson") # 计算相关系数矩阵
        rvalue = xy_corr.iloc[0,1]
        rvalue = round(rvalue,2) # 提取相关系数
        pval_matrix = xy.corr(method=lambda x, y: pearsonr(x, y)[1]) - np.eye(len(xy.columns)) # 计算 p 值矩阵
        pval = pval_matrix.iloc[0,1] # 提取 p 值
        plot_rvalue_and_pvalue(rvalue,pval) # 写上相关系数和显著性水平
        
        
        col = col.replace('/', 'sub')
        savepath = filepath + col + ".pdf" 
        plt.savefig(savepath, bbox_inches = 'tight') # 保存图片

        plt.show() # 展示图片
    return out_dict,tmp
```


```python
df_names = ["3.1.5","c1","c2","c3"]
traits_names = ["维管束和机械强度","维管束和细胞壁","机械强度和细胞壁"]

# for df in dvs:
for i in range(4):
    df = dvs[i]
    df_name = df_names[i]
    tmp = df.iloc[:,7:]
    tmp_cols = tmp.columns.tolist()
    vb_cols = tmp_cols[:31] # 维管束性状
    jx_cols = tmp.columns[tmp.columns.str.contains('四')].tolist() # 机械强度性状
    xbb_cols = tmp_cols[-11:-5] # 细胞壁性状
    
    dvb_jx = tmp[vb_cols + jx_cols]
    dvb_xbb = tmp[vb_cols + xbb_cols]
    djx_xbb = tmp[jx_cols + xbb_cols]
    
    traits_list = [dvb_jx,dvb_xbb,djx_xbb]
#     for traits in traits_list:
    for j in range(3):
        traits = traits_list[j]
        traits_name = traits_names[j]
        #皮尔森相关系数
        pearson = traits.corr(method="pearson")
        sns.clustermap(pearson,
#                cmap="vlag",
               linewidths=.1,
               figsize=(40, 40),               
               annot=True, 
               fmt=".2g",                 
               cbar_kws={"shrink": 0.25,"pad":0.01,}
              )
        savepath = wd + "范/" + df_name + traits_name + ".pdf"
        plt.savefig(savepath,bbox_inches = 'tight')
        plt.show()
```

```python
# 获得重要性状两年比值
# 20220808更新
def cols_impot_boxplot(data,cols_impot):
    tmp = data.copy()
    for col in cols_impot:
        new_col = col + "比"
        xname = col + "_x"
        yname = col + "_y"     
        tmp[new_col] = data[yname] / data[xname]

        sns.boxplot(new_col,data=tmp)
        sns.swarmplot(new_col,data=tmp)
        plt.show()
    return tmp
```
```python
def plot_rvalue_and_pvalue(rvalue,pval):
    if pval < 0.01:
        xing = "{**}"
    elif pval < 0.05:
        xing = "{*}"
    else:
        xing = " "
        
    text_plot(rvalue,xing)
```

```python
def get_outliner_index_shougong(data,index,col,ma,mi):
    """
    获得异常值的索引名/编号
    :param data: 接收 pandas.DataFrame 数据格式
    :param index: 索引所在列的名字
    :param cols: 选择的性状
    :param ma: 数字，最大值
    :param mi: 数字，最小值
    """  
    col = col + "比"
    minimun,maximun = ma,mi
    pzbh_list = data[(data[col] < minimun) | (data[col] > maximun)][index].tolist() 
    #     out_dict[col] = {"outliners": pzbh_list}
    return pzbh_list
```

```python
def get_outliners_list(data,cols_impot):
    out_dict = {}
    for col in cols_impot:
        col = col + "比"
        minimun,maximun = get_outliers(data[col],1.5)
        pzbh_list = data[(data[col] < minimun) | (data[col] > maximun)]["品种编号"].tolist() 
        out_dict[col] = pzbh_list
    #     out_dict[col] = {"outliners": pzbh_list}
    
#     print(out_dict)
    # 先把这些异常值并集的样本去掉
    out_list = []
    for key, value in out_dict.items():
        print(key,value)
        out_list = out_list + value
        
    out_list = list(set(out_list)) # 去掉重复值
    print("out_list:",out_list)
    print("out_list length:",len(out_list)) 
    return out_list
 
out_list = get_outliners_list(d3,cols_impot)
```
```python
def get_outliers(data_ser, box_scale):
        """
        获得异常值的上下边界
        :param data_ser: 接收 pandas.Series 数据格式
        :param box_scale: 箱线图尺度，一般为 1.5
        """      
        iqr = data_ser.quantile(0.75) - data_ser.quantile(0.25)
        minimum = data_ser.quantile(0.25) - box_scale * iqr
        maximum = data_ser.quantile(0.75) + box_scale * iqr

        return (minimum,maximum)
```

```python
def plot_r(rvalue):
    if abs(rvalue) > 0.589714:
        xing = "{**}"
        text_plot(rvalue,xing)
#         elif abs(rvalue) > 0.204968:
    elif abs(rvalue) > 0.468277:
        xing = "{*}"
        text_plot(rvalue,xing)
    else:
        xing = " "
        text_plot(rvalue,xing)
```



```python
import seaborn as sns
import matplotlib.pyplot as plt
from pylab import mpl

fig = plt.figure(figsize=(30, 20))
gs = gridspec.GridSpec(3,7)  #     gs = gridspec.GridSpec(2,3, width_ratios=[2,2,3.5]) 

for i in range(21):
    ax = plt.subplot(gs[i])      
#     sns.set_style('white')
    
    color = ["#46b0fc","#a859ba", "#ec0503", "#00d6ac" ]
    
    trait = cols[i+1]
    x = data["cluster"]
    y = data[trait]
    
    if trait == "大维管束平均面积(mm²)" :
        sns.boxplot(x=x,y=y,palette=color,boxprops=dict(alpha=.4),showfliers=False)
        sns.swarmplot(x=x,y=y,palette=color)

        mpl.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体

        ylabel = names.loc[trait,"性状无单位"] + names.loc[trait,"单位"] + "\n" + names.loc[trait,"英文公式"]
        plt.ylabel(ylabel,fontsize=30)
        plt.xlabel(None)
        plt.xticks(fontsize=30)
        plt.yticks(fontsize=30)
        plt.yticks(np.arange(0, 0.051, step=0.01)) # 刻度太密集，手工设置刻度
    elif trait == "小维管束平均面积(mm²)":
        sns.boxplot(x=x,y=y,palette=color,boxprops=dict(alpha=.4),showfliers=False)
        sns.swarmplot(x=x,y=y,palette=color)

        mpl.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体

        ylabel = names.loc[trait,"性状无单位"] + names.loc[trait,"单位"] + "\n" + names.loc[trait,"英文公式"]
        plt.ylabel(ylabel,fontsize=30)
        plt.xlabel(None)
        plt.xticks(fontsize=30)
        plt.yticks(fontsize=30)
        plt.yticks(np.arange(0, 0.021, step=0.01)) # 刻度太密集，手工设置刻度
    else:
        sns.boxplot(x=x,y=y,palette=color,boxprops=dict(alpha=.4),showfliers=False)
        sns.swarmplot(x=x,y=y,palette=color)

        mpl.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体

        ylabel = names.loc[trait,"性状无单位"] + names.loc[trait,"单位"] + "\n" + names.loc[trait,"英文公式"]
        plt.ylabel(ylabel,fontsize=32)
        plt.xlabel(None)
        plt.xticks(fontsize=32)
        plt.yticks(fontsize=32)
        



plt.tight_layout(pad=0.4, w_pad=0.5, h_pad=1.0)
plt.savefig("../箱线图3乘7.pdf",bbox_inches = 'tight')
plt.show()
    
```
## 单个 boxplot 按类别
```python
def traits_cluster_boxplot(data,savepath):
    """
    对每一个变量箱线图图
    data：没有 index 只有变量 cols 的 DataFrame，第一列是 cluster
    savepath：图片保存的路径，以斜杠结尾
    """  
    
    import seaborn as sns
    import matplotlib.pyplot as plt
    from pylab import mpl
    
    sns.set_style('white')
    
    cols = data.columns.tolist()
    for col in cols[1:]:
        plt.figure(figsize=(4,6))
#         sns.boxplot(x=data["cluster"],y=data[col],palette="Set2",showfliers=False)
#         sns.swarmplot(x=data["cluster"],y=data[col],palette="Set2")
        color = ["#46b0fc","#a859ba", "#ec0503", "#00d6ac" ]
        sns.boxplot(x=data["cluster"],y=data[col],palette=color,boxprops=dict(alpha=.4),showfliers=False)
        sns.swarmplot(x=data["cluster"],y=data[col],palette=color)
#         sns.swarmplot(x=data["cluster"],y=data[col],color=sns.color_palette("Set2")[1])
    
        mpl.rcParams['font.sans-serif'] = ['SimHei'] # 指定默认字体
        
        ylabel = names.loc[col,"性状无单位"] + names.loc[col,"单位"] + "\n" + names.loc[col,"英文公式"]
        plt.ylabel(ylabel)
        plt.xlabel(None)
        
        col = col.replace("/","sub")
        savename = savepath + col + ".pdf" 
        plt.savefig(savename,bbox_inches = 'tight')

        plt.show()

```

## 散点图加回归线和相关系数
```python
def text_plot(rvalue,xing):
    rvalue = str(round(rvalue,2)) # 取两位小数
    words = "$r=" + "{" + rvalue + "}^" + xing + "$"
    #         words = "$\mathrm{r=" + "{" + rvalue + "}^" + xing + "}$"
    #         words = "$\mathrm{r=" + "{" + rvalue + "}^" + "{\star}" + "}$"
    print(words)
             #         plt.text(1, 1, equation,ha='center', va='center',transform=plt.gca().transAxes)  
    plt.text(0.01, 0.88, words, fontsize=30, transform=plt.gca().transAxes)
    
def plot_r(rvalue):
    if abs(rvalue) > 0.337549:             
            xing = "{***}"
            text_plot(rvalue,xing)
    elif abs(rvalue) > 0.267298:
        xing = "{**}"
        text_plot(rvalue,xing)
#         elif abs(rvalue) > 0.204968:
    elif abs(rvalue) > 0.195:
        xing = "{*}"
        text_plot(rvalue,xing)
    else:
        xing = "1"
        text_plot(rvalue,xing)
        
import matplotlib.gridspec as gridspec
fig = plt.figure(figsize=(30, 18))
gs = gridspec.GridSpec(3,4)  #     gs = gridspec.GridSpec(2,3, width_ratios=[2,2,3.5]) 


# 先画穗重
for i in range(4):
    ax = plt.subplot(gs[i])
#     ax0 = fig.add_subplot(gs[0, 0])

    y = hxh1[[zs_order[0]]]
    x = hxh1[[sz_order[i]]]

    p = sns.regplot(x,y,data=hxh1,color="b",scatter_kws={'alpha':0.3})

    ylabel = names.loc[zs_order[0],"性状无单位"] + names.loc[zs_order[0],"单位"] + "\n" + names.loc[zs_order[0],"英文公式"]
    xlabel = names.loc[sz_order[i],"性状无单位"] + names.loc[sz_order[i],"单位"] + "\n" + names.loc[sz_order[i],"英文公式"]

    plt.ylabel(ylabel,fontsize=30)
    plt.xlabel(xlabel,fontsize=30)
    
    slope,intercept,rvalue,pvalue,stderr = scipy.stats.linregress(x = x.iloc[:,0], y = y.iloc[:,0])
    plot_r(rvalue)
    
# 再画百粒重
for i in range(5):
    ax = plt.subplot(gs[i+4])
#     ax0 = fig.add_subplot(gs[0, 0])

    y = hxh2[[zs_order[1]]]
    x = hxh2[[blz_order[i]]]

    p = sns.regplot(x,y,data=hxh2,color="b",scatter_kws={'alpha':0.3})

    ylabel = names.loc[zs_order[1],"性状无单位"] + names.loc[zs_order[1],"单位"] + "\n" + names.loc[zs_order[1],"英文公式"]
    xlabel = names.loc[blz_order[i],"性状无单位"] + names.loc[blz_order[i],"单位"] + "\n" + names.loc[blz_order[i],"英文公式"]

    plt.ylabel(ylabel,fontsize=30)
    plt.xlabel(xlabel,fontsize=30)   
    
    slope,intercept,rvalue,pvalue,stderr = scipy.stats.linregress(x = x.iloc[:,0], y = y.iloc[:,0])
    plot_r(rvalue)
    
# 最后画枝梗数
for i in range(3):
    ax = plt.subplot(gs[i+9])
#     ax0 = fig.add_subplot(gs[0, 0])

    y = hxh3[[zs_order[2]]]
    x = hxh3[[zg_order[i]]]

    p = sns.regplot(x,y,data=hxh3,color="b",scatter_kws={'alpha':0.3})

    ylabel = names.loc[zs_order[2],"性状无单位"] + names.loc[zs_order[2],"单位"] + "\n" + names.loc[zs_order[2],"英文公式"]
    xlabel = names.loc[zg_order[i],"性状无单位"] + names.loc[zg_order[i],"单位"] + "\n" + names.loc[zg_order[i],"英文公式"]

    plt.ylabel(ylabel,fontsize=30)
    plt.xlabel(xlabel,fontsize=30)
    
    slope,intercept,rvalue,pvalue,stderr = scipy.stats.linregress(x = x.iloc[:,0], y = y.iloc[:,0])
    plot_r(rvalue)
    
    
    
plt.tight_layout(pad=0.4, w_pad=0.5, h_pad=1.0)
plt.savefig("../散点图拼图3乘4v2.pdf",bbox_inches = 'tight')





```
